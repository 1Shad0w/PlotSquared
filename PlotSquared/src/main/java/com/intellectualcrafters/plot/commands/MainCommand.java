/*
 * Copyright (c) IntellectualCrafters - 2014. You are not allowed to distribute
 * and/or monetize any of our intellectual property. IntellectualCrafters is not
 * affiliated with Mojang AB. Minecraft is a trademark of Mojang AB.
 * 
 * >> File = MainCommand.java >> Generated by: Citymonstret at 2014-08-09 01:42
 */

package com.intellectualcrafters.plot.commands;

import com.intellectualcrafters.plot.C;
import com.intellectualcrafters.plot.PlayerFunctions;
import com.intellectualcrafters.plot.PlotMain;
import com.intellectualcrafters.plot.StringComparsion;

import org.bukkit.ChatColor;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabCompleter;
import org.bukkit.entity.Player;
import org.bukkit.util.ChatPaginator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * PlotMain command class
 *
 * @author Citymonstret
 */
public class MainCommand implements CommandExecutor, TabCompleter {

	private static SubCommand[] _subCommands = new SubCommand[] { new Claim(), new Paste(), new Copy(), new Clipboard(), new Auto(), new Home(), new Visit(),
			new TP(), new Set(), new Clear(), new Delete(), new SetOwner(), new Denied(), new Helpers(), new Trusted(),
			new Info(), new list(), new Help(), new Debug(), new Schematic(), new plugin(), new Inventory(), new Purge(),
			new Reload(), new Merge(), new Unlink(), new Kick(), new Setup(), new DebugClaimTest(), new Inbox(), new Comment(), new Swap(), new MusicSubcommand() };

	public static ArrayList<SubCommand> subCommands = new ArrayList<SubCommand>() {
		{
			addAll(Arrays.asList(_subCommands));
		}
	};

	public static boolean no_permission(Player player, String permission) {
		PlayerFunctions.sendMessage(player, C.NO_PERMISSION, permission);
		return false;
	}

	@Override
	public boolean onCommand(CommandSender sender, Command cmd, String commandLabel, String[] args) {
		Player player = (sender instanceof Player) ? (Player) sender : null;

        if (!PlotMain.hasPermission(player, "plots.use"))
			return no_permission(player, "plots.use");

		if ((args.length < 1)
				|| ((args.length >= 1) && (args[0].equalsIgnoreCase("help") || args[0].equalsIgnoreCase("he")))) {
			if (args.length < 2) {
				StringBuilder builder = new StringBuilder();
				builder.append(C.HELP_INFO.s());
				for (SubCommand.CommandCategory category : SubCommand.CommandCategory.values()) {
					builder.append("\n").append(C.HELP_INFO_ITEM.s().replaceAll("%category%", category.toString().toLowerCase()).replaceAll("%category_desc%", category.toString()));
				}
				PlayerFunctions.sendMessage(player, builder.toString());
				return true;
			}
			String cat = args[1];
			SubCommand.CommandCategory cato = null;
			for (SubCommand.CommandCategory category : SubCommand.CommandCategory.values()) {
				if (cat.equalsIgnoreCase(category.toString())) {
					cato = category;
					break;
				}
			}
			if (cato == null) {
				StringBuilder builder = new StringBuilder();
				builder.append(C.HELP_INFO.s());
				for (SubCommand.CommandCategory category : SubCommand.CommandCategory.values()) {
					builder.append("\n").append(C.HELP_INFO_ITEM.s().replaceAll("%category%", category.toString().toLowerCase()).replaceAll("%category_desc%", category.toString()));
				}
				PlayerFunctions.sendMessage(player, builder.toString());
				return true;
			}
			StringBuilder help = new StringBuilder();
            int page = 0;

            boolean digit = true;
            for(char c : args[2].toCharArray())
                if(!Character.isDigit(c)) {
                    digit = false;
                    break;
                }
            if(digit) {
                page = Integer.parseInt(args[2]);
                if(--page < 0) page = 0;
            }

            for(String string : helpMenu(player, cato, page))
                help.append(string).append("\n");

			PlayerFunctions.sendMessage(player, help.toString());
			return true;
		}
		else {
			for (SubCommand command : subCommands) {
				if (command.cmd.equalsIgnoreCase(args[0]) || command.alias.equalsIgnoreCase(args[0])) {
					String[] arguments = new String[args.length - 1];
                    System.arraycopy(args, 1, arguments, 0, args.length - 1);
					if (command.permission.hasPermission(player)) {
						if (player!=null || !command.isPlayer ) {
							return command.execute(player, arguments);
						}
						else {
							PlayerFunctions.sendMessage(null, C.IS_CONSOLE);
							return false;
						}
					}
					else {
						return no_permission(player, command.permission.permission.toLowerCase());
					}
				}
			}
			PlayerFunctions.sendMessage(player, C.NOT_VALID_SUBCOMMAND);

            String[] commands = new String[subCommands.size()];
            for(int x = 0; x < subCommands.size(); x++)
                commands[x] = subCommands.get(x).cmd;

            PlayerFunctions.sendMessage(player, C.DID_YOU_MEAN, new StringComparsion(args[0], commands).getBestMatch());
		}
		return false;
	}


    public static List<SubCommand> getCommands(SubCommand.CommandCategory category, Player player) {
        List<SubCommand> cmds = new ArrayList<>();
        for(SubCommand c : subCommands)
            if(c.category == category && c.permission.hasPermission(player))
                cmds.add(c);
        return cmds;
    }

    /*
    // Current page
                    int page = 0;

                    //is a page specified? else use 0
                    if(args.length > 1) {
                        try {
                           page = Integer.parseInt(args[1]);
                        } catch(Exception e) {
                            page = 0;
                        }
                    }

                    //Get the total pages
                    int totalPages = ((int) Math.ceil(12 * (PlotMain.getPlotsSorted().size()) / 100));

                    if(page > totalPages)
                        page = totalPages;

                    //Only display 12!
                    int max = (page * 12) + 12;

                    if(max > PlotMain.getPlotsSorted().size())
                        max = PlotMain.getPlotsSorted().size();

                    StringBuilder string = new StringBuilder();

                    string.append(C.PLOT_LIST_HEADER_PAGED.s().replaceAll("%cur", page + 1 + "").replaceAll("%max", totalPages + 1 + "").replaceAll("%word%", "all") + "\n");
					Plot p;

                    //This might work xD
                    for (int x = (page * 12); x < max; x++) {
     */
	public static ArrayList<String> helpMenu(Player player, final SubCommand.CommandCategory category, int page) {
        List<SubCommand> commands = getCommands(category, player);
        //final int totalPages = ((int) Math.ceil(12 * (commands.size()) / 100));
        int perPage = 5;
        int totalPages = (int) Math.ceil(commands.size() / perPage);
        if(page > totalPages)
            page = totalPages;
        int max = (page * perPage) + perPage;
        if(max > commands.size())
            max = commands.size();
		ArrayList<String> help = new ArrayList<>(
                Arrays.asList(
                        t(C.HELP_HEADER.s().replaceAll("%cur", page + 1 + "").replaceAll("%max", totalPages + 1 + "")),
                        t(C.HELP_CATEGORY.s().replaceAll("%category%", category.toString()))
                ));
        SubCommand cmd;

        String lines = "";
        for(int x = 0; x < ChatPaginator.GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH * 0.75; x++) {
            lines += "-";
        }

        int start = page * perPage;
        for(int x = start; x < max; x++) {
            cmd = subCommands.get(x);
            String s = t(C.HELP_PAGE.s());
            s = s.replaceAll("%alias%", cmd.alias);
            s = s.replaceAll("%usage%", cmd.usage.contains("plot") ? cmd.usage : "/plot " + cmd.usage);
            s = s.replaceAll("%cmd%", cmd.cmd);
            s = s.replaceAll("%desc%", cmd.description);

            help.add(s);

            if(x != start && x != max - 1) {
                help.add(t(C.HELP_ITEM_SEPARATOR.s().replaceAll("%lines", lines)));
            }

        }
		if (help.size() < 2) {
			help.add(t(C.NO_COMMANDS.s()));
		}
		return help;
	}

	private static String t(String s) {
		return ChatColor.translateAlternateColorCodes('&', s);
	}

    @Override
    public List<String> onTabComplete(CommandSender commandSender, Command command, String s, String[] strings) {
        if(!(commandSender instanceof Player)) return null;
        Player player = (Player) commandSender;
        
        if(strings.length < 1) {
            if (strings.length==0 || "plots".startsWith(s)) {
                return Arrays.asList(new String[] {"plots"});
            }
        }
        if (strings.length > 1) {
            return null;
        }
        if (!command.getLabel().equalsIgnoreCase("plots")) {
            return null;
        }
        List<String> tabOptions = new ArrayList<String>();
        String arg = strings[0].toLowerCase();
        for (SubCommand cmd : subCommands) {
            if (cmd.permission.hasPermission(player)) {
                if (cmd.cmd.startsWith(arg)) {
                    tabOptions.add(cmd.cmd);
                }
                else if (cmd.alias.startsWith(arg)) {
                    tabOptions.add(cmd.alias);
                }
            }
        }
        if(tabOptions.size()>0) {
            return tabOptions;
        }
        return null;
    }
}
