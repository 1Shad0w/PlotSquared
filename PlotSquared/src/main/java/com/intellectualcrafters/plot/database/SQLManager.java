/*
 * Copyright (c) IntellectualCrafters - 2014. You are not allowed to distribute
 * and/or monetize any of our intellectual property. IntellectualCrafters is not
 * affiliated with Mojang AB. Minecraft is a trademark of Mojang AB.
 * 
 * >> File = DBFunc.java >> Generated by: Citymonstret at 2014-08-09 01:43
 */

package com.intellectualcrafters.plot.database;

import com.intellectualcrafters.plot.*;
import com.intellectualcrafters.plot.Logger.LogLevel;
import org.apache.commons.lang.StringUtils;
import org.bukkit.Bukkit;
import org.bukkit.OfflinePlayer;
import org.bukkit.block.Biome;

import java.sql.*;
import java.util.*;

import static com.intellectualcrafters.plot.PlotMain.connection;
import static com.intellectualcrafters.plot.Settings.DB.PREFIX;

/**
 * @author Citymonstret
 */
public class SQLManager extends AbstractDB {

	// TODO MongoDB @Brandon


    public static final String SET_OWNER = "UPDATE `" + PREFIX + "plot` SET `owner` = ? WHERE `plot_id_x` = ? AND `plot_id_z` = ?";
    public static final String GET_ALL_PLOTS = "SELECT `id`, `plot_id_x`, `plot_id_z`, `world` FROM `" + PREFIX + "plot`";
    public static final String CREATE_PLOTS = "INSERT INTO `" + PREFIX + "plot`(`plot_id_x`, `plot_id_z`, `owner`, `world`) values ";
    public static final String CREATE_SETTINGS = "INSERT INTO `" + PREFIX + "plot_settings` (`plot_plot_id`) values ";
    public static final String CREATE_HELPERS = "INSERT INTO `" + PREFIX + "plot_helpers` (`plot_plot_id`, `user_uuid`) values ";
    public static final String CREATE_PLOT = "INSERT INTO `" + PREFIX + "plot`(`plot_id_x`, `plot_id_z`, `owner`, `world`) VALUES(?, ?, ?, ?)";
	/**
	 * Set Plot owner
	 * 
	 * @param plot
	 * @param uuid
	 */
    public  void setOwner(final Plot plot, final UUID uuid) {
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement statement =
							connection.prepareStatement(SET_OWNER);
					statement.setString(1, uuid.toString());
					statement.setInt(2, plot.id.x);
					statement.setInt(3, plot.id.y);
					statement.executeUpdate();
					statement.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.DANGER, "Could not set owner for plot " + plot.id);
				}
			}
		});
	}

	@Override
	public void createAllSettingsAndHelpers(ArrayList<Plot> plots) {
	    // TODO SEVERE [ More than 5000 plots will fail in a single SQLite query.
		HashMap<String, HashMap<PlotId, Integer>> stored = new HashMap<String, HashMap<PlotId, Integer>>();
		HashMap<Integer, ArrayList<UUID>> helpers = new HashMap<Integer, ArrayList<UUID>>();
		try {
			PreparedStatement stmt =
					connection.prepareStatement(GET_ALL_PLOTS);
			ResultSet result = stmt.executeQuery();
			while (result.next()) {
				int id = result.getInt("id");
				int idx = result.getInt("plot_id_x");
				int idz = result.getInt("plot_id_z");
				String world = result.getString("world");

				if (!stored.containsKey(world)) {
					stored.put(world, new HashMap<PlotId, Integer>());
				}
				stored.get(world).put(new PlotId(idx, idz), id);
			}
		}
		catch (SQLException e) {
			e.printStackTrace();
		}

		for (Plot plot : plots) {
			String world = Bukkit.getWorld(plot.world).getName();
			if (stored.containsKey(world)) {
				Integer id = stored.get(world).get(plot.id);
				if (id != null) {
					helpers.put(id, plot.helpers);
				}
			}
		}

		if (helpers.size() == 0) {
			return;
		}

		// add plot settings
		Integer[] ids = helpers.keySet().toArray(new Integer[0]);
		StringBuilder statement = new StringBuilder(CREATE_SETTINGS);
		for (int i = 0; i < (ids.length - 1); i++) {
			statement.append("(?),");
		}
		statement.append("(?)");
		PreparedStatement stmt = null;
		try {
			stmt = connection.prepareStatement(statement.toString());
			for (int i = 0; i < ids.length; i++) {
				stmt.setInt(i + 1, ids[i]);
			}
			stmt.executeUpdate();
			stmt.close();
		}
		catch (SQLException e) {
			e.printStackTrace();
		}

		// add plot helpers
		String prefix = "";
		statement = new StringBuilder(CREATE_HELPERS);
		for (Integer id : helpers.keySet()) {
			for (UUID helper : helpers.get(id)) {
				statement.append(prefix + "(?, ?)");
				prefix = ",";
			}
		}
		if (prefix.equals("")) {
			return;
		}
		try {
			stmt = connection.prepareStatement(statement.toString());
			int counter = 0;
			for (Integer id : helpers.keySet()) {
				for (UUID helper : helpers.get(id)) {

					stmt.setInt((counter * 2) + 1, id);
					stmt.setString((counter * 2) + 2, helper.toString());
					counter++;
				}
			}
			stmt.executeUpdate();
			stmt.close();
		}
		catch (SQLException e) {
			Logger.add(LogLevel.WARNING, "Failed to set helper for plots");
			e.printStackTrace();
		}
	}

	/**
	 * Create a plot
	 * 
	 * @param plots
	 */
	@Override
	public void createPlots(ArrayList<Plot> plots) {
		
		// TODO SEVERE [ More than 5000 plots will fail in a single SQLite query.
		
		if (plots.size() == 0) {
			return;
		}
		StringBuilder statement =
				new StringBuilder(CREATE_PLOTS);

		for (int i = 0; i < (plots.size() - 1); i++) {
			statement.append("(?,?,?,?),");
		}
		statement.append("(?,?,?,?)");

		PreparedStatement stmt = null;
		try {
			stmt = connection.prepareStatement(statement.toString());
			for (int i = 0; i < plots.size(); i++) {
				Plot plot = plots.get(i);
				stmt.setInt((i * 4) + 1, plot.id.x);
				stmt.setInt((i * 4) + 2, plot.id.y);
				stmt.setString((i * 4) + 3, plot.owner.toString());
				stmt.setString((i * 4) + 4, plot.world);
			}
			stmt.executeUpdate();
			stmt.close();
		}
		catch (SQLException e) {
			e.printStackTrace();
			Logger.add(LogLevel.DANGER, "Failed to save plots!");
		}
	}

	/**
	 * Create a plot
	 * 
	 * @param plot
	 */
	@Override
	public void createPlot(Plot plot) {
		PreparedStatement stmt = null;
		try {
			stmt =
					connection.prepareStatement(CREATE_PLOT);
			stmt.setInt(1, plot.id.x);
			stmt.setInt(2, plot.id.y);
			stmt.setString(3, plot.owner.toString());
			stmt.setString(4, plot.world);
			stmt.executeUpdate();
			stmt.close();
		}
		catch (SQLException e) {
			e.printStackTrace();
			Logger.add(LogLevel.DANGER, "Failed to save plot " + plot.id);
		}
	}

	/**
	 * Create tables
	 * 
	 * @throws SQLException
	 */
	@Override
	public void createTables(String database, boolean add_constraint) throws SQLException {
		boolean mysql = database.equals("mysql");
		Statement stmt = connection.createStatement();
		if (mysql) {
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot` (" + "`id` INT(11) NOT NULL AUTO_INCREMENT,"
					+ "`plot_id_x` INT(11) NOT NULL," + "`plot_id_z` INT(11) NOT NULL,"
					+ "`owner` VARCHAR(45) NOT NULL," + "`world` VARCHAR(45) NOT NULL,"
					+ "`timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP," + "PRIMARY KEY (`id`)"
					+ ") ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=0");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_denied` (" + "`plot_plot_id` INT(11) NOT NULL,"
					+ "`user_uuid` VARCHAR(40) NOT NULL" + ") ENGINE=InnoDB DEFAULT CHARSET=utf8");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_helpers` (" + "`plot_plot_id` INT(11) NOT NULL,"
					+ "`user_uuid` VARCHAR(40) NOT NULL" + ") ENGINE=InnoDB DEFAULT CHARSET=utf8");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_trusted` (" + "`plot_plot_id` INT(11) NOT NULL,"
					+ "`user_uuid` VARCHAR(40) NOT NULL" + ") ENGINE=InnoDB DEFAULT CHARSET=utf8");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_settings` (" + "  `plot_plot_id` INT(11) NOT NULL,"
					+ "  `biome` VARCHAR(45) DEFAULT 'FOREST'," + "  `rain` INT(1) DEFAULT 0,"
					+ "  `custom_time` TINYINT(1) DEFAULT '0'," + "  `time` INT(11) DEFAULT '8000',"
					+ "  `deny_entry` TINYINT(1) DEFAULT '0'," + "  `alias` VARCHAR(50) DEFAULT NULL,"
					+ "  `flags` VARCHAR(512) DEFAULT NULL," + "  `merged` INT(11) DEFAULT NULL,"
					+ "  `position` VARCHAR(50) NOT NULL DEFAULT 'DEFAULT'," + "  PRIMARY KEY (`plot_plot_id`),"
					+ "  UNIQUE KEY `unique_alias` (`alias`)" + ") ENGINE=InnoDB DEFAULT CHARSET=utf8");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_ratings` ( `plot_plot_id` INT(11) NOT NULL, `rating` INT(2) NOT NULL, `player` VARCHAR(40) NOT NULL, PRIMARY KEY(`plot_plot_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8");
			if (add_constraint) {
				stmt.addBatch("ALTER TABLE `" + PREFIX + "plot_settings` ADD CONSTRAINT `"+ PREFIX + "plot_settings_ibfk_1` FOREIGN KEY (`plot_plot_id`) REFERENCES `"+PREFIX+"plot` (`id`) ON DELETE CASCADE");
			}

		}
		else {
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot` (" + "`id` INTEGER PRIMARY KEY AUTOINCREMENT,"
					+ "`plot_id_x` INT(11) NOT NULL," + "`plot_id_z` INT(11) NOT NULL,"
					+ "`owner` VARCHAR(45) NOT NULL," + "`world` VARCHAR(45) NOT NULL,"
					+ "`timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP)");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_denied` (" + "`plot_plot_id` INT(11) NOT NULL,"
					+ "`user_uuid` VARCHAR(40) NOT NULL" + ")");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_helpers` (" + "`plot_plot_id` INT(11) NOT NULL,"
					+ "`user_uuid` VARCHAR(40) NOT NULL" + ")");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_trusted` (" + "`plot_plot_id` INT(11) NOT NULL,"
					+ "`user_uuid` VARCHAR(40) NOT NULL" + ")");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_settings` (" + "  `plot_plot_id` INT(11) NOT NULL,"
					+ "  `biome` VARCHAR(45) DEFAULT 'FOREST'," + "  `rain` INT(1) DEFAULT 0,"
					+ "  `custom_time` TINYINT(1) DEFAULT '0'," + "  `time` INT(11) DEFAULT '8000',"
					+ "  `deny_entry` TINYINT(1) DEFAULT '0'," + "  `alias` VARCHAR(50) DEFAULT NULL,"
					+ "  `flags` VARCHAR(512) DEFAULT NULL," + "  `merged` INT(11) DEFAULT NULL,"
					+ "  `position` VARCHAR(50) NOT NULL DEFAULT 'DEFAULT'," + "  PRIMARY KEY (`plot_plot_id`)" + ")");
			stmt.addBatch("CREATE TABLE IF NOT EXISTS `" + PREFIX + "plot_ratings` (`plot_plot_id` INT(11) NOT NULL, `rating` INT(2) NOT NULL, `player` VARCHAR(40) NOT NULL, PRIMARY KEY(`plot_plot_id`))");
		}
		stmt.executeBatch();
		stmt.clearBatch();
		stmt.close();
	}

	/**
	 * Delete a plot
	 * 
	 * @param plot
	 */
	@Override
	public void delete(final String world, final Plot plot) {
		PlotMain.removePlot(world, plot.id, false);
		runTask(new Runnable() {
			@Override
			public void run() {
				PreparedStatement stmt = null;
				int id = getId(world, plot.id);
				try {
					stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_settings` WHERE `plot_plot_id` = ?");
					stmt.setInt(1, id);
					stmt.executeUpdate();
					stmt.close();
					stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_helpers` WHERE `plot_plot_id` = ?");
					stmt.setInt(1, id);
					stmt.executeUpdate();
					stmt.close();
					stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_trusted` WHERE `plot_plot_id` = ?");
					stmt.setInt(1, id);
					stmt.executeUpdate();
					stmt.close();
					stmt = connection.prepareStatement("DELETE FROM `"+ PREFIX +"plot` WHERE `id` = ?");
					stmt.setInt(1, id);
					stmt.executeUpdate();
					stmt.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.DANGER, "Failed to delete plot " + plot.id);
				}
			}
		});
	}

	/**
	 * Create plot settings
	 * 
	 * @param id
	 * @param plot
	 */
	@Override
	public void createPlotSettings(final int id, final Plot plot) {
		runTask(new Runnable() {
			@Override
			public void run() {
				PreparedStatement stmt = null;
				try {
					stmt = connection.prepareStatement("INSERT INTO `"+ PREFIX +"plot_settings`(`plot_plot_id`) VALUES(" + "?)");
					stmt.setInt(1, id);
					stmt.executeUpdate();
					stmt.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
				}

			}
		});
	}

	@Override
	public int getId(String world, PlotId id2) {
		PreparedStatement stmt = null;
		try {
			stmt = connection.prepareStatement("SELECT `id` FROM `"+ PREFIX +"plot` WHERE `plot_id_x` = ? AND `plot_id_z` = ? AND world = ? ORDER BY `timestamp` ASC");
			stmt.setInt(1, id2.x);
			stmt.setInt(2, id2.y);
			stmt.setString(3, world);
			ResultSet r = stmt.executeQuery();
			int id = Integer.MAX_VALUE;
			while (r.next()) {
				id = r.getInt("id");
			}
			stmt.close();
			return id;
		}
		catch (SQLException e) {
			e.printStackTrace();
		}
		return Integer.MAX_VALUE;
	}

	/**
	 * @return
	 */
	@Override
	public HashMap<String, HashMap<PlotId, Plot>> getPlots() {
	    HashMap<String, HashMap<PlotId, Plot>> newplots = new HashMap<String, HashMap<PlotId, Plot>>();
		try {
			DatabaseMetaData data = connection.getMetaData();
			ResultSet rs = data.getColumns(null, null, PREFIX+"plot", "plot_id");
			boolean execute = rs.next();
			if (execute) {
				Statement statement = connection.createStatement();
				statement.addBatch("ALTER IGNORE TABLE `" + PREFIX + "plot` ADD `plot_id_x` int(11) DEFAULT 0");
				statement.addBatch("ALTER IGNORE TABLE `" + PREFIX +"plot` ADD `plot_id_z` int(11) DEFAULT 0");
				statement.addBatch("UPDATE `"+PREFIX+"plot` SET\n" + "    `plot_id_x` = IF("
						+ "        LOCATE(';', `plot_id`) > 0,"
						+ "        SUBSTRING(`plot_id`, 1, LOCATE(';', `plot_id`) - 1)," + "        `plot_id`"
						+ "    )," + "    `plot_id_z` = IF(" + "        LOCATE(';', `plot_id`) > 0,"
						+ "        SUBSTRING(`plot_id`, LOCATE(';', `plot_id`) + 1)," + "        NULL" + "    )");
				statement.addBatch("ALTER TABLE `" + PREFIX +"plot` DROP `plot_id`");
				statement.addBatch("ALTER IGNORE TABLE `" + PREFIX +"plot_settings` ADD `flags` VARCHAR(512) DEFAULT NULL");
				statement.executeBatch();
				statement.close();
			}
			rs = data.getColumns(null, null, PREFIX + "plot_settings", "merged");
			if (!rs.next()) {
				Statement statement = connection.createStatement();
				statement.addBatch("ALTER TABLE `" + PREFIX + "plot_settings` ADD `merged` int(11) DEFAULT NULL");
				statement.executeBatch();
				statement.close();
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		HashMap<Integer, Plot> plots = new HashMap<Integer, Plot>(); 
		
		
		Statement stmt = null;
		try {

			Set<String> worlds = new HashSet<String>();
			if (PlotMain.config.contains("worlds")) {
				worlds = PlotMain.config.getConfigurationSection("worlds").getKeys(false);
			}
			
			HashMap<String, UUID> uuids = new HashMap<String, UUID>();
			HashMap<String, Integer> noExist = new HashMap<String, Integer>();
			
			/*
             * Getting plots
             */
			stmt = connection.createStatement();
			ResultSet r = stmt.executeQuery("SELECT `id`, `plot_id_x`, `plot_id_z`, `owner`, `world` FROM `" + PREFIX +"plot`");
			PlotId plot_id;
			int id;
			Plot p;
			String o;
			UUID user;
			while (r.next()) {
				plot_id = new PlotId(r.getInt("plot_id_x"), r.getInt("plot_id_z"));
				id = r.getInt("id");
				String worldname = r.getString("world");
				if (!worlds.contains(worldname)) {
				    if (noExist.containsKey(worldname)) {
				        noExist.put(worldname,noExist.get(worldname)+1);
				    }
				    else {
				        noExist.put(worldname,1);
				    }
				}
				o = r.getString("owner");
				user = uuids.get(o);
				if (user==null) {
				    user = UUID.fromString(o);
				    uuids.put(o, user);
				}
				p = new Plot(plot_id, user, Biome.FOREST, new ArrayList<UUID>(), new ArrayList<UUID>(), new ArrayList<UUID>(), "", PlotHomePosition.DEFAULT, null, worldname, new boolean[] {false, false, false, false});
				plots.put(id, p);
			}
			stmt.close();
			
			/*
			 * Getting helpers
			 */
			stmt = connection.createStatement();
            r = stmt.executeQuery("SELECT `user_uuid`, `plot_plot_id` FROM `" + PREFIX + "plot_helpers`");
            while (r.next()) {
                id = r.getInt("plot_plot_id");
                o = r.getString("user_uuid");
                user = uuids.get(o);
                if (user==null) {
                    user = UUID.fromString(o);
                    uuids.put(o, user);
                }
                Plot plot = plots.get(id);
                if (plot!=null) {
                    plot.addHelper(user);
                }
                else {
                    PlotMain.sendConsoleSenderMessage("&cPLOT "+id+" in plot_helpers does not exist. Please create the plot or remove this entry.");
                }
            }
            stmt.close();
            
            /*
             * Getting trusted
             */
            stmt = connection.createStatement();
            r = stmt.executeQuery("SELECT `user_uuid`, `plot_plot_id` FROM `" + PREFIX + "plot_trusted`");
            while (r.next()) {
                id = r.getInt("plot_plot_id");
                o = r.getString("user_uuid");
                user = uuids.get(o);
                if (user==null) {
                    user = UUID.fromString(o);
                    uuids.put(o, user);
                }
                Plot plot = plots.get(id);
                if (plot!=null) {
                    plot.addTrusted(user);
                }
                else {
                    PlotMain.sendConsoleSenderMessage("&cPLOT "+id+" in plot_trusted does not exist. Please create the plot or remove this entry.");
                }
            }
            stmt.close();
            
            /*
             * Getting denied
             */
            stmt = connection.createStatement();
            r = stmt.executeQuery("SELECT `user_uuid`, `plot_plot_id` FROM `" + PREFIX + "plot_denied`");
            while (r.next()) {
                id = r.getInt("plot_plot_id");
                o = r.getString("user_uuid");
                user = uuids.get(o);
                if (user==null) {
                    user = UUID.fromString(o);
                    uuids.put(o, user);
                }
                Plot plot = plots.get(id);
                if (plot!=null) {
                    plot.addDenied(user);
                }
                else {
                    PlotMain.sendConsoleSenderMessage("&cPLOT "+id+" in plot_denied does not exist. Please create the plot or remove this entry.");
                }
            }
            stmt.close();
			
            stmt = connection.createStatement();
            r = stmt.executeQuery("SELECT * FROM `" + PREFIX + "plot_settings`");
            String var;
            Object val;
            while (r.next()) {
                id = r.getInt("plot_plot_id");
                Plot plot = plots.get(id);
                if (plot!=null) {
                    
                    String b = r.getString("biome");
                    Biome biome = null;
                    if (b!=null) {
                        for (Biome mybiome : Biome.values()) {
                            if (mybiome.toString().equalsIgnoreCase(b)) {
                                biome = mybiome;
                                break;
                            }
                        }
                    }
                    if (biome==null) {
                        biome = Biome.FOREST;
                    }
                    plot.settings.setBiome(biome);
                    
                    String alias = r.getString("alias");
                    if (alias!=null) {
                        plot.settings.setAlias(alias);
                    }
                    
                    PlotHomePosition position = null;
                    String pos = r.getString("position");
                    if (pos!=null) {
                        for (PlotHomePosition plotHomePosition : PlotHomePosition.values()) {
                            if (plotHomePosition.isMatching(pos)) {
                                if (plotHomePosition!=PlotHomePosition.DEFAULT) {
                                    plot.settings.setPosition(plotHomePosition);
                                }
                                break;
                            }
                        }
                    }
                    Integer m = r.getInt("merged");
                    if (m!=null) {
                        boolean[] merged = new boolean[4];
                        for (int i = 0; i < 4; i++) {
                            merged[3 - i] = (((int) m) & (1 << i)) != 0;
                        }
                        plot.settings.setMerged(merged);
                    }
                    else {
                        plot.settings.setMerged(new boolean[] {false, false, false, false});
                    }
                    
                    String[] flags_string;
                    String myflags = r.getString("flags");
                    if (myflags == null) {
                        flags_string = new String[] {};
                    }
                    else {
                        flags_string = myflags.split(",");
                    }
                    ArrayList<Flag> flags = new ArrayList<Flag>();
                    boolean exception = false;
                    for (int i = 0; i < flags_string.length; i++) {
                        if (flags_string[i].contains(":")) {
                            String[] split = flags_string[i].split(":");
                            try {
                                flags.add(new Flag(FlagManager.getFlag(split[0], true), split[1]));
                            }
                            catch (Exception e) {
                                exception = true;
                            }
                        }
                        else {
                            flags.add(new Flag(FlagManager.getFlag(flags_string[i], true), ""));
                        }
                    }
                    if (exception) {
                        PlotMain.sendConsoleSenderMessage("&cPlot "+id+" had an invalid flag. A fix has been attempted.");
                        setFlags(id, flags.toArray(new Flag[0]));
                    }
                    plot.settings.setFlags(flags.toArray(new Flag[0]));
                }
                else {
                    PlotMain.sendConsoleSenderMessage("&cPLOT "+id+" in plot_settings does not exist. Please create the plot or remove this entry.");
                }
            }
            stmt.close();
            for (Plot plot:plots.values()) {
                String world = plot.world;
                if (!newplots.containsKey(world)) {
                    newplots.put(world, new HashMap<PlotId, Plot>());
                }
                newplots.get(world).put(plot.id, plot);
            }
			for (String worldname: noExist.keySet()) {
				PlotMain.sendConsoleSenderMessage("&c[WARNING] Found "+noExist.get(worldname)+" plots in DB for non existant world; '"+worldname+"'!!!\n&c - Please create this world, or remove the plots from the DB using the purge command!");
			}
		}
		catch (SQLException e) {
			Logger.add(LogLevel.WARNING, "Failed to load plots.");
			e.printStackTrace();
		}
		return newplots;
	}


	@Override
	public void setMerged(final String world, final Plot plot, final boolean[] merged) {
		plot.settings.setMerged(merged);
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					int n = 0;
					for (int i = 0; i < 4; ++i) {
						n = (n << 1) + (merged[i] ? 1 : 0);
					}
					PreparedStatement stmt =
							connection.prepareStatement("UPDATE `" + PREFIX + "plot_settings` SET `merged` = ? WHERE `plot_plot_id` = ?");
					stmt.setInt(1, n);
					stmt.setInt(2, getId(world, plot.id));
					stmt.execute();
					stmt.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.WARNING, "Could not set merged for plot " + plot.id);
				}
			}
		});
	}

	@Override
	public void setFlags(final String world, final Plot plot, final Flag[] flags) {
		plot.settings.setFlags(flags);
		final StringBuilder flag_string = new StringBuilder();
		int i = 0;
		for (Flag flag : flags) {
			if (i != 0) {
				flag_string.append(",");
			}
			flag_string.append(flag.getKey() + ":" + flag.getValue());
			i++;
		}
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement stmt =
							connection.prepareStatement("UPDATE `" + PREFIX + "plot_settings` SET `flags` = ? WHERE `plot_plot_id` = ?");
					stmt.setString(1, flag_string.toString());
					stmt.setInt(2, getId(world, plot.id));
					stmt.execute();
					stmt.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.WARNING, "Could not set flag for plot " + plot.id);
				}
			}
		});
	}
	
    public void setFlags(final int id, final Flag[] flags) {
        ArrayList<Flag> newflags = new ArrayList<Flag>();
        for (Flag flag : flags) {
            if (flag!=null && flag.getKey()!=null && !flag.getKey().equals("")) {
                newflags.add(flag);
            }
        }
        final String flag_string = StringUtils.join(newflags,",");
        runTask(new Runnable() {
            @Override
            public void run() {
                try {
                    PreparedStatement stmt =
                            connection.prepareStatement("UPDATE `" + PREFIX + "plot_settings` SET `flags` = ? WHERE `plot_plot_id` = ?");
                    stmt.setString(1, flag_string);
                    stmt.setInt(2, id);
                    stmt.execute();
                    stmt.close();
                }
                catch (SQLException e) {
                    e.printStackTrace();
                    Logger.add(LogLevel.WARNING, "Could not set flag for plot " + id);
                }
            }
        });
    }

	/**
	 * @param plot
	 * @param alias
	 */
	@Override
	public void setAlias(final String world, final Plot plot, final String alias) {
		plot.settings.setAlias(alias);
		runTask(new Runnable() {
			@Override
			public void run() {
				PreparedStatement stmt = null;
				try {
					stmt =
							connection.prepareStatement("UPDATE `" + PREFIX + "plot_settings` SET `alias` = ?  WHERE `plot_plot_id` = ?");
					stmt.setString(1, alias);
					stmt.setInt(2, getId(world, plot.id));
					stmt.executeUpdate();
					stmt.close();
				}
				catch (SQLException e) {
					Logger.add(LogLevel.WARNING, "Failed to set alias for plot " + plot.id);
					e.printStackTrace();
				}

			}
		});
	}

	/**
	 * @param r
	 */
	private  void runTask(Runnable r) {
		PlotMain.getMain().getServer().getScheduler().runTaskAsynchronously(PlotMain.getMain(), r);
	}
	
	@Override
	public void purge(final String world, final PlotId id) {
	    runTask(new Runnable() {
            @Override
            public void run() {
                ArrayList<Integer> ids = new ArrayList<Integer>();
                
                // Fetching a list of plot IDs for a world
                try {
                    PreparedStatement stmt = connection.prepareStatement("SELECT `id` FROM `" + PREFIX + "plot` WHERE `world` = ? AND `plot_id_x` = ? AND `plot_id_z` = ?");
                    stmt.setString(1, world);
                    stmt.setInt(2, id.x);
                    stmt.setInt(3, id.y);
                    ResultSet result = stmt.executeQuery();
                    while (result.next()) {
                        int id = result.getInt("id");
                        ids.add(id);
                    }
                }
                catch (SQLException e) {
                    e.printStackTrace();
                    Logger.add(LogLevel.WARNING, "FAILED TO PURGE WORLD '"+world+"'!");
                    return;
                }
                if (ids.size() > 0) {
                    try {
                        
                        String prefix = "";
                        StringBuilder idstr = new StringBuilder("");
                        
                        for (Integer id:ids) {
                            idstr.append(prefix + id);
                            prefix = " OR `plot_plot_id` = ";
                        }
                        
                        PreparedStatement stmt = connection.prepareStatement("DELETE FROM `" + PREFIX +"plot_helpers` WHERE `plot_plot_id` = "+idstr+"");
                        stmt.executeUpdate();
                        stmt.close();
                        
                        stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_denied` WHERE `plot_plot_id` = "+idstr+"");
                        stmt.executeUpdate();
                        stmt.close();
                        
                        stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_settings` WHERE `plot_plot_id` = "+idstr+"");
                        stmt.executeUpdate();
                        stmt.close();
                        
                        stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_trusted` WHERE `plot_plot_id` = "+idstr+"");
                        stmt.executeUpdate();
                        stmt.close();
                        
                        stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot` WHERE `plot_plot_id` = "+idstr+"");
                        stmt.setString(1, world);
                        stmt.executeUpdate();
                        stmt.close();
                    }
                    catch (SQLException e) {
                        e.printStackTrace();
                        Logger.add(LogLevel.DANGER, "FAILED TO PURGE PLOT FROM DB '"+world+"' , '"+id+"' !");
                        return;
                    }
                }
                Logger.add(LogLevel.GENERAL, "SUCCESSFULLY PURGED PLOT FROM DB '"+world+"' , '"+id+"'!");
            }
        }); 
	}

	@Override
	public void purge(final String world) {
		runTask(new Runnable() {
			@Override
			public void run() {
				ArrayList<Integer> ids = new ArrayList<Integer>();
				
				// Fetching a list of plot IDs for a world
				try {
					PreparedStatement stmt = connection.prepareStatement("SELECT `id` FROM `" + PREFIX + "plot` WHERE `world` = ?");
					stmt.setString(1, world);
					ResultSet result = stmt.executeQuery();
					while (result.next()) {
						int id = result.getInt("id");
						ids.add(id);
					}
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.WARNING, "FAILED TO PURGE WORLD '"+world+"'!");
					return;
				}
				if (ids.size() > 0) {
    				try {
    					
    					String prefix = "";
    					StringBuilder idstr = new StringBuilder("");
    					
    					for (Integer id:ids) {
    						idstr.append(prefix + id);
    						prefix = " OR `plot_plot_id` = ";
    					}
    					
    					PreparedStatement stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_helpers` WHERE `plot_plot_id` = "+idstr+"");
    					stmt.executeUpdate();
    					stmt.close();
    					
    					stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_denied` WHERE `plot_plot_id` = "+idstr+"");
    					stmt.executeUpdate();
    					stmt.close();
    					
    					stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_settings` WHERE `plot_plot_id` = "+idstr+"");
                        stmt.executeUpdate();
                        stmt.close();
                        
                        stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_trusted` WHERE `plot_plot_id` = "+idstr+"");
                        stmt.executeUpdate();
                        stmt.close();
    					
    					stmt = connection.prepareStatement("DELETE FROM `" + PREFIX + "plot` WHERE `world` = ?");
    					stmt.setString(1, world);
    					stmt.executeUpdate();
    					stmt.close();
    				}
    				catch (SQLException e) {
    					e.printStackTrace();
    					Logger.add(LogLevel.DANGER, "FAILED TO PURGE WORLD '"+world+"'!");
    					return;
    				}
				}
				Logger.add(LogLevel.GENERAL, "SUCCESSFULLY PURGED WORLD '"+world+"'!");
			}
		});
	}
	
	/**
	 * @param plot
	 * @param position
	 */
	@Override
	public void setPosition(final String world, final Plot plot, final String position) {
		plot.settings.setPosition(PlotHomePosition.valueOf(position));
		runTask(new Runnable() {
			@Override
			public void run() {
				PreparedStatement stmt = null;
				try {
					stmt =
							connection.prepareStatement("UPDATE `" + PREFIX + "plot_settings` SET `position` = ?  WHERE `plot_plot_id` = ?");
					stmt.setString(1, position);
					stmt.setInt(2, getId(world, plot.id));
					stmt.executeUpdate();
					stmt.close();
				}
				catch (SQLException e) {
					Logger.add(LogLevel.WARNING, "Failed to set position for plot " + plot.id);
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * @param id
	 * @return
	 */
	@Override
	public HashMap<String, Object> getSettings(int id) {
		HashMap<String, Object> h = new HashMap<String, Object>();
		PreparedStatement stmt = null;
		try {
			stmt = connection.prepareStatement("SELECT * FROM `" + PREFIX + "plot_settings` WHERE `plot_plot_id` = ?");
			stmt.setInt(1, id);
			ResultSet r = stmt.executeQuery();
			String var;
			Object val;
			while (r.next()) {
				var = "biome";
				val = r.getObject(var);
				h.put(var, val);
				var = "rain";
				val = r.getObject(var);
				h.put(var, val);
				var = "custom_time";
				val = r.getObject(var);
				h.put(var, val);
				var = "time";
				val = r.getObject(var);
				h.put(var, val);
				var = "deny_entry";
				val = r.getObject(var);
				h.put(var, (short) 0);
				var = "alias";
				val = r.getObject(var);
				h.put(var, val);
				var = "position";
				val = r.getObject(var);
				h.put(var, val);
				var = "flags";
				val = r.getObject(var);
				h.put(var, val);
				var = "merged";
				val = r.getObject(var);
				h.put(var, val);
			}
			stmt.close();
			;
		}
		catch (SQLException e) {
			Logger.add(LogLevel.WARNING, "Failed to load settings for plot: " + id);
			e.printStackTrace();
		}
		return h;
	}
	/**
	 * @param id
	 * @return
	 */
	private  ArrayList<UUID> plotDenied(int id) {
		ArrayList<UUID> l = new ArrayList<UUID>();
		PreparedStatement stmt = null;
		try {
			stmt = connection.prepareStatement("SELECT `user_uuid` FROM `" + PREFIX + "plot_denied` WHERE `plot_plot_id` = ?");
			stmt.setInt(1, id);
			ResultSet r = stmt.executeQuery();
			UUID u;
			while (r.next()) {
				u = UUID.fromString(r.getString("user_uuid"));
				l.add(u);
			}
			stmt.close();
		}
		catch (Exception e) {
			Logger.add(LogLevel.DANGER, "Failed to load denied for plot: " + id);
			e.printStackTrace();
		}
		return l;
	}

	/**
	 * @param id
	 * @return
	 */
	private  ArrayList<UUID> plotHelpers(int id) {
		ArrayList<UUID> l = new ArrayList<UUID>();
		Statement stmt = null;
		try {
			stmt = connection.createStatement();
			ResultSet r = stmt.executeQuery("SELECT `user_uuid` FROM `" + PREFIX + "plot_helpers` WHERE `plot_plot_id` = " + id);
			UUID u;
			while (r.next()) {
				u = UUID.fromString(r.getString("user_uuid"));
				l.add(u);
			}
			stmt.close();
		}
		catch (SQLException e) {
			Logger.add(LogLevel.WARNING, "Failed to load helpers for plot: " + id);
			e.printStackTrace();
		}
		return l;
	}

	/**
	 * @param id
	 * @return
	 */
	private  ArrayList<UUID> plotTrusted(int id) {
		ArrayList<UUID> l = new ArrayList<UUID>();
		Statement stmt = null;
		try {
			stmt = connection.createStatement();
			ResultSet r = stmt.executeQuery("SELECT `user_uuid` FROM `" + PREFIX + "plot_trusted` WHERE `plot_plot_id` = " + id);
			UUID u;
			while (r.next()) {
				u = UUID.fromString(r.getString("user_uuid"));
				l.add(u);
			}
			stmt.close();
		}
		catch (SQLException e) {
			Logger.add(LogLevel.WARNING, "Failed to load trusted users for plot: " + id);
			e.printStackTrace();
		}
		return l;
	}

	/**
	 * @param plot
	 * @param player
	 */
	@Override
	public void removeHelper(final String world, final Plot plot, final OfflinePlayer player) {
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement statement =
							connection.prepareStatement("DELETE FROM `"+PREFIX+"plot_helpers` WHERE `plot_plot_id` = ? AND `user_uuid` = ?");
					statement.setInt(1, getId(world, plot.id));
					statement.setString(2, player.getUniqueId().toString());
					statement.executeUpdate();
					statement.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.WARNING, "Failed to remove helper for plot " + plot.id);
				}
			}
		});
	}

	/**
	 * @param plot
	 * @param player
	 */
	@Override
	public void removeTrusted(final String world, final Plot plot, final OfflinePlayer player) {
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement statement =
							connection.prepareStatement("DELETE FROM `"+PREFIX+"plot_trusted` WHERE `plot_plot_id` = ? AND `user_uuid` = ?");
					statement.setInt(1, getId(world, plot.id));
					statement.setString(2, player.getUniqueId().toString());
					statement.executeUpdate();
					statement.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.WARNING, "Failed to remove trusted user for plot " + plot.id);
				}
			}
		});
	}

	/**
	 * @param plot
	 * @param player
	 */
	@Override
	public void setHelper(final String world, final Plot plot, final OfflinePlayer player) {
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement statement =
							connection.prepareStatement("INSERT INTO `" + PREFIX + "plot_helpers` (`plot_plot_id`, `user_uuid`) VALUES(?,?)");
					statement.setInt(1, getId(world, plot.id));
					statement.setString(2, player.getUniqueId().toString());
					statement.executeUpdate();
					statement.close();
				}
				catch (SQLException e) {
					Logger.add(LogLevel.WARNING, "Failed to set helper for plot " + plot.id);
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * @param plot
	 * @param player
	 */
	@Override
	public void setTrusted(final String world, final Plot plot, final OfflinePlayer player) {
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement statement =
							connection.prepareStatement("INSERT INTO `" + PREFIX + "plot_trusted` (`plot_plot_id`, `user_uuid`) VALUES(?,?)");
					statement.setInt(1, getId(world, plot.id));
					statement.setString(2, player.getUniqueId().toString());
					statement.executeUpdate();
					statement.close();
				}
				catch (SQLException e) {
					Logger.add(LogLevel.WARNING, "Failed to set plot trusted for plot " + plot.id);
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * @param plot
	 * @param player
	 */
	@Override
	public void removeDenied(final String world, final Plot plot, final OfflinePlayer player) {
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement statement =
							connection.prepareStatement("DELETE FROM `" + PREFIX + "plot_denied` WHERE `plot_plot_id` = ? AND `user_uuid` = ?");
					statement.setInt(1, getId(world, plot.id));
					statement.setString(2, player.getUniqueId().toString());
					statement.executeUpdate();
					statement.close();
				}
				catch (SQLException e) {
					e.printStackTrace();
					Logger.add(LogLevel.WARNING, "Failed to remove denied for plot " + plot.id);
				}
			}
		});
	}

	/**
	 * @param plot
	 * @param player
	 */
	@Override
	public void setDenied(final String world, final Plot plot, final OfflinePlayer player) {
		runTask(new Runnable() {
			@Override
			public void run() {
				try {
					PreparedStatement statement =
							connection.prepareStatement("INSERT INTO `" + PREFIX + "plot_denied` (`plot_plot_id`, `user_uuid`) VALUES(?,?)");
					statement.setInt(1, getId(world, plot.id));
					statement.setString(2, player.getUniqueId().toString());
					statement.executeUpdate();
					statement.close();
				}
				catch (SQLException e) {
					Logger.add(LogLevel.WARNING, "Failed to set denied for plot " + plot.id);
					e.printStackTrace();
				}
			}
		});
	}

	@Override
	public double getRatings(final Plot plot) {
		try {
			PreparedStatement statement =
					connection.prepareStatement("SELECT AVG(`rating`) AS `rating` FROM `" + PREFIX + "plot_ratings` WHERE `plot_plot_id` = ? ");
			statement.setInt(1, getId(plot.getWorld().getName(), plot.id));
			ResultSet set = statement.executeQuery();
			double rating = 0;
			while (set.next()) {
				rating = set.getDouble("rating");
			}
			statement.close();
			return rating;
		}
		catch (SQLException e) {
			Logger.add(LogLevel.WARNING, "Failed to fetch rating for plot " + plot.getId().toString());
			e.printStackTrace();
		}
		return 0.0d;
	}
}
